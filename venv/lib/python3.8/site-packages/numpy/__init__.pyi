import builtins
import os
import sys
import mmap
import ctypes as ct
import array as _array
import datetime as dt
from abc import abstractmethod
from types import TracebackType
from contextlib import ContextDecorator

from numpy.core._internal import _ctypes
from numpy.typing import (
    # Arrays
    ArrayLike,
    NDArray,
    _SupportsArray,
    _NestedSequence,
    _RecursiveSequence,
    _SupportsArray,
    _ArrayLikeBool_co,
    _ArrayLikeUInt_co,
    _ArrayLikeInt_co,
    _ArrayLikeFloat_co,
    _ArrayLikeComplex_co,
    _ArrayLikeNumber_co,
    _ArrayLikeTD64_co,
    _ArrayLikeDT64_co,
    _ArrayLikeObject_co,

    # DTypes
    DTypeLike,
    _SupportsDType,
    _VoidDTypeLike,

    # Shapes
    _Shape,
    _ShapeLike,

    # Scalars
    _CharLike_co,
    _BoolLike_co,
    _IntLike_co,
    _FloatLike_co,
    _ComplexLike_co,
    _TD64Like_co,
    _NumberLike_co,
    _ScalarLike_co,

    # `number` precision
    NBitBase,
    _256Bit,
    _128Bit,
    _96Bit,
    _80Bit,
    _64Bit,
    _32Bit,
    _16Bit,
    _8Bit,
    _NBitByte,
    _NBitShort,
    _NBitIntC,
    _NBitIntP,
    _NBitInt,
    _NBitLongLong,
    _NBitHalf,
    _NBitSingle,
    _NBitDouble,
    _NBitLongDouble,

    # Character codes
    _BoolCodes,
    _UInt8Codes,
    _UInt16Codes,
    _UInt32Codes,
    _UInt64Codes,
    _Int8Codes,
    _Int16Codes,
    _Int32Codes,
    _Int64Codes,
    _Float16Codes,
    _Float32Codes,
    _Float64Codes,
    _Complex64Codes,
    _Complex128Codes,
    _ByteCodes,
    _ShortCodes,
    _IntCCodes,
    _IntPCodes,
    _IntCodes,
    _LongLongCodes,
    _UByteCodes,
    _UShortCodes,
    _UIntCCodes,
    _UIntPCodes,
    _UIntCodes,
    _ULongLongCodes,
    _HalfCodes,
    _SingleCodes,
    _DoubleCodes,
    _LongDoubleCodes,
    _CSingleCodes,
    _CDoubleCodes,
    _CLongDoubleCodes,
    _DT64Codes,
    _TD64Codes,
    _StrCodes,
    _BytesCodes,
    _VoidCodes,
    _ObjectCodes,

    # Ufuncs
    _UFunc_Nin1_Nout1,
    _UFunc_Nin2_Nout1,
    _UFunc_Nin1_Nout2,
    _UFunc_Nin2_Nout2,
    _GUFunc_Nin2_Nout1,
)

from numpy.typing._callable import (
    _BoolOp,
    _BoolBitOp,
    _BoolSub,
    _BoolTrueDiv,
    _BoolMod,
    _BoolDivMod,
    _TD64Div,
    _IntTrueDiv,
    _UnsignedIntOp,
    _UnsignedIntBitOp,
    _UnsignedIntMod,
    _UnsignedIntDivMod,
    _SignedIntOp,
    _SignedIntBitOp,
    _SignedIntMod,
    _SignedIntDivMod,
    _FloatOp,
    _FloatMod,
    _FloatDivMod,
    _ComplexOp,
    _NumberOp,
    _ComparisonOp,
)

# NOTE: Numpy's mypy plugin is used for removing the types unavailable
# to the specific platform
from numpy.typing._extended_precision import (
    uint128 as uint128,
    uint256 as uint256,
    int128 as int128,
    int256 as int256,
    float80 as float80,
    float96 as float96,
    float128 as float128,
    float256 as float256,
    complex160 as complex160,
    complex192 as complex192,
    complex256 as complex256,
    complex512 as complex512,
)

from typing import (
    Any,
    ByteString,
    Callable,
    Container,
    Callable,
    Dict,
    Generic,
    IO,
    Iterable,
    List,
    Mapping,
    NoReturn,
    Optional,
    overload,
    Sequence,
    Sized,
    SupportsComplex,
    SupportsFloat,
    SupportsInt,
    Text,
    Tuple,
    Type,
    TypeVar,
    Union,
)

if sys.version_info >= (3, 8):
    from typing import Literal as L, Protocol, SupportsIndex, Final
else:
    from typing_extensions import Literal as L, Protocol, SupportsIndex, Final

# Ensures that the stubs are picked up
from numpy import (
    char as char,
    ctypeslib as ctypeslib,
    fft as fft,
    lib as lib,
    linalg as linalg,
    ma as ma,
    matrixlib as matrixlib,
    polynomial as polynomial,
    random as random,
    rec as rec,
    testing as testing,
    version as version,
)

from numpy.core.function_base import (
    linspace as linspace,
    logspace as logspace,
    geomspace as geomspace,
)

from numpy.core.fromnumeric import (
    take as take,
    reshape as reshape,
    choose as choose,
    repeat as repeat,
    put as put,
    swapaxes as swapaxes,
    transpose as transpose,
    partition as partition,
    argpartition as argpartition,
    sort as sort,
    argsort as argsort,
    argmax as argmax,
    argmin as argmin,
    searchsorted as searchsorted,
    resize as resize,
    squeeze as squeeze,
    diagonal as diagonal,
    trace as trace,
    ravel as ravel,
    nonzero as nonzero,
    shape as shape,
    compress as compress,
    clip as clip,
    sum as sum,
    all as all,
    any as any,
    cumsum as cumsum,
    ptp as ptp,
    amax as amax,
    amin as amin,
    prod as prod,
    cumprod as cumprod,
    ndim as ndim,
    size as size,
    around as around,
    mean as mean,
    std as std,
    var as var,
)

from numpy.core._asarray import (
    asarray as asarray,
    asanyarray as asanyarray,
    ascontiguousarray as ascontiguousarray,
    asfortranarray as asfortranarray,
    require as require,
)

from numpy.core._type_aliases import (
    sctypes as sctypes,
    sctypeDict as sctypeDict,
)

from numpy.core._ufunc_config import (
    seterr as seterr,
    geterr as geterr,
    setbufsize as setbufsize,
    getbufsize as getbufsize,
    seterrcall as seterrcall,
    geterrcall as geterrcall,
    _SupportsWrite,
    _ErrKind,
    _ErrFunc,
    _ErrDictOptional,
)

from numpy.core.arrayprint import (
    set_printoptions as set_printoptions,
    get_printoptions as get_printoptions,
    array2string as array2string,
    format_float_scientific as format_float_scientific,
    format_float_positional as format_float_positional,
    array_repr as array_repr,
    array_str as array_str,
    set_string_function as set_string_function,
    printoptions as printoptions,
)

from numpy.core.einsumfunc import (
    einsum as einsum,
    einsum_path as einsum_path,
)

from numpy.core.numeric import (
    zeros_like as zeros_like,
    ones as ones,
    ones_like as ones_like,
    empty_like as empty_like,
    full as full,
    full_like as full_like,
    count_nonzero as count_nonzero,
    isfortran as isfortran,
    argwhere as argwhere,
    flatnonzero as flatnonzero,
    correlate as correlate,
    convolve as convolve,
    outer as outer,
    tensordot as tensordot,
    roll as roll,
    rollaxis as rollaxis,
    moveaxis as moveaxis,
    cross as cross,
    indices as indices,
    fromfunction as fromfunction,
    isscalar as isscalar,
    binary_repr as binary_repr,
    base_repr as base_repr,
    identity as identity,
    allclose as allclose,
    isclose as isclose,
    array_equal as array_equal,
    array_equiv as array_equiv,
)

from numpy.core.numerictypes import (
    maximum_sctype as maximum_sctype,
    issctype as issctype,
    obj2sctype as obj2sctype,
    issubclass_ as issubclass_,
    issubsctype as issubsctype,
    issubdtype as issubdtype,
    sctype2char as sctype2char,
    find_common_type as find_common_type,
    nbytes as nbytes,
    cast as cast,
    ScalarType as ScalarType,
    typecodes as typecodes,
)

from numpy.core.shape_base import (
    atleast_1d as atleast_1d,
    atleast_2d as atleast_2d,
    atleast_3d as atleast_3d,
    block as block,
    hstack as hstack,
    stack as stack,
    vstack as vstack,
)

from numpy.lib import (
    emath as emath,
)

from numpy.lib.arraypad import (
    pad as pad,
)

from numpy.lib.arraysetops import (
    ediff1d as ediff1d,
    intersect1d as intersect1d,
    setxor1d as setxor1d,
    union1d as union1d,
    setdiff1d as setdiff1d,
    unique as unique,
    in1d as in1d,
    isin as isin,
)

from numpy.lib.arrayterator import (
    Arrayterator as Arrayterator,
)

from numpy.lib.function_base import (
    select as select,
    piecewise as piecewise,
    trim_zeros as trim_zeros,
    copy as copy,
    iterable as iterable,
    percentile as percentile,
    diff as diff,
    gradient as gradient,
    angle as angle,
    unwrap as unwrap,
    sort_complex as sort_complex,
    disp as disp,
    flip as flip,
    rot90 as rot90,
    extract as extract,
    place as place,
    asarray_chkfinite as asarray_chkfinite,
    average as average,
    bincount as bincount,
    digitize as digitize,
    cov as cov,
    corrcoef as corrcoef,
    msort as msort,
    median as median,
    sinc as sinc,
    hamming as hamming,
    hanning as hanning,
    bartlett as bartlett,
    blackman as blackman,
    kaiser as kaiser,
    trapz as trapz,
    i0 as i0,
    add_newdoc as add_newdoc,
    add_docstring as add_docstring,
    meshgrid as meshgrid,
    delete as delete,
    insert as insert,
    append as append,
    interp as interp,
    add_newdoc_ufunc as add_newdoc_ufunc,
    quantile as quantile,
)

from numpy.lib.index_tricks import (
    ravel_multi_index as ravel_multi_index,
    unravel_index as unravel_index,
    mgrid as mgrid,
    ogrid as ogrid,
    r_ as r_,
    c_ as c_,
    s_ as s_,
    index_exp as index_exp,
    ix_ as ix_,
    fill_diagonal as fill_diagonal,
    diag_indices as diag_indices,
    diag_indices_from as diag_indices_from,
)

from numpy.lib.nanfunctions import (
    nansum as nansum,
    nanmax as nanmax,
    nanmin as nanmin,
    nanargmax as nanargmax,
    nanargmin as nanargmin,
    nanmean as nanmean,
    nanmedian as nanmedian,
    nanpercentile as nanpercentile,
    nanvar as nanvar,
    nanstd as nanstd,
    nanprod as nanprod,
    nancumsum as nancumsum,
    nancumprod as nancumprod,
    nanquantile as nanquantile,
)

from numpy.lib.npyio import (
    savetxt as savetxt,
    loadtxt as loadtxt,
    genfromtxt as genfromtxt,
    recfromtxt as recfromtxt,
    recfromcsv as recfromcsv,
    load as load,
    loads as loads,
    save as save,
    savez as savez,
    savez_compressed as savez_compressed,
    packbits as packbits,
    unpackbits as unpackbits,
    fromregex as fromregex,
)

from numpy.lib.polynomial import (
    poly as poly,
    roots as roots,
    polyint as polyint,
    polyder as polyder,
    polyadd as polyadd,
    polysub as polysub,
    polymul as polymul,
    polydiv as polydiv,
    polyval as polyval,
    polyfit as polyfit,
)

from numpy.lib.shape_base import (
    column_stack as column_stack,
    row_stack as row_stack,
    dstack as dstack,
    array_split as array_split,
    split as split,
    hsplit as hsplit,
    vsplit as vsplit,
    dsplit as dsplit,
    apply_over_axes as apply_over_axes,
    expand_dims as expand_dims,
    apply_along_axis as apply_along_axis,
    kron as kron,
    tile as tile,
    get_array_wrap as get_array_wrap,
    take_along_axis as take_along_axis,
    put_along_axis as put_along_axis,
)

from numpy.lib.stride_tricks import (
    broadcast_to as broadcast_to,
    broadcast_arrays as broadcast_arrays,
    broadcast_shapes as broadcast_shapes,
)

from numpy.lib.twodim_base import (
    diag as diag,
    diagflat as diagflat,
    eye as eye,
    fliplr as fliplr,
    flipud as flipud,
    tri as tri,
    triu as triu,
    tril as tril,
    vander as vander,
    histogram2d as histogram2d,
    mask_indices as mask_indices,
    tril_indices as tril_indices,
    tril_indices_from as tril_indices_from,
    triu_indices as triu_indices,
    triu_indices_from as triu_indices_from,
)

from numpy.lib.type_check import (
    mintypecode as mintypecode,
    asfarray as asfarray,
    real as real,
    imag as imag,
    iscomplex as iscomplex,
    isreal as isreal,
    iscomplexobj as iscomplexobj,
    isrealobj as isrealobj,
    nan_to_num as nan_to_num,
    real_if_close as real_if_close,
    typename as typename,
    common_type as common_type,
)

from numpy.lib.ufunclike import (
    fix as fix,
    isposinf as isposinf,
    isneginf as isneginf,
)

from numpy.lib.utils import (
    issubclass_ as issubclass_,
    issubsctype as issubsctype,
    issubdtype as issubdtype,
    deprecate as deprecate,
    deprecate_with_doc as deprecate_with_doc,
    get_include as get_include,
    info as info,
    source as source,
    who as who,
    lookfor as lookfor,
    byte_bounds as byte_bounds,
    safe_eval as safe_eval,
)

__all__: List[str]
__path__: List[str]
__version__: str
__git_version__: str

# TODO: Move placeholders to their respective module once
# their annotations are properly implemented
#
# Placeholders for classes
# TODO: Remove `__getattr__` once the classes are stubbed out
class MachAr:
    def __init__(
        self,
        float_conv: Any = ...,
        int_conv: Any = ...,
        float_to_float: Any = ...,
        float_to_str: Any = ...,
        title: Any = ...,
    ) -> None: ...
    def __getattr__(self, key: str) -> Any: ...

class busdaycalendar:
    def __new__(cls, weekmask: Any = ..., holidays: Any = ...) -> Any: ...
    def __getattr__(self, key: str) -> Any: ...

class chararray(ndarray[_ShapeType, _DType_co]):
    def __new__(
        subtype,
        shape: Any,
        itemsize: Any = ...,
        unicode: Any = ...,
        buffer: Any = ...,
        offset: Any = ...,
        strides: Any = ...,
        order: Any = ...,
    ) -> Any: ...
    def __array_finalize__(self, obj): ...
    def argsort(self, axis=..., kind=..., order=...): ...
    def capitalize(self): ...
    def center(self, width, fillchar=...): ...
    def count(self, sub, start=..., end=...): ...
    def decode(self, encoding=..., errors=...): ...
    def encode(self, encoding=..., errors=...): ...
    def endswith(self, suffix, start=..., end=...): ...
    def expandtabs(self, tabsize=...): ...
    def find(self, sub, start=..., end=...): ...
    def index(self, sub, start=..., end=...): ...
    def isalnum(self): ...
    def isalpha(self): ...
    def isdigit(self): ...
    def islower(self): ...
    def isspace(self): ...
    def istitle(self): ...
    def isupper(self): ...
    def join(self, seq): ...
    def ljust(self, width, fillchar=...): ...
    def lower(self): ...
    def lstrip(self, chars=...): ...
    def partition(self, sep): ...
    def replace(self, old, new, count=...): ...
    def rfind(self, sub, start=..., end=...): ...
    def rindex(self, sub, start=..., end=...): ...
    def rjust(self, width, fillchar=...): ...
    def rpartition(self, sep): ...
    def rsplit(self, sep=..., maxsplit=...): ...
    def rstrip(self, chars=...): ...
    def split(self, sep=..., maxsplit=...): ...
    def splitlines(self, keepends=...): ...
    def startswith(self, prefix, start=..., end=...): ...
    def strip(self, chars=...): ...
    def swapcase(self): ...
    def title(self): ...
    def translate(self, table, deletechars=...): ...
    def upper(self): ...
    def zfill(self, width): ...
    def isnumeric(self): ...
    def isdecimal(self): ...

class finfo:
    def __new__(cls, dtype: Any) -> Any: ...
    def __getattr__(self, key: str) -> Any: ...

class format_parser:
    def __init__(
        self,
        formats: Any,
        names: Any,
        titles: Any,
        aligned: Any = ...,
        byteorder: Any = ...,
    ) -> None: ...

class iinfo:
    def __init__(self, int_type: Any) -> None: ...
    def __getattr__(self, key: str) -> Any: ...

class matrix(ndarray[_ShapeType, _DType_co]):
    def __new__(
        subtype,
        data: Any,
        dtype: Any = ...,
        copy: Any = ...,
    ) -> Any: ...
    def __array_finalize__(self, obj): ...
    def __getitem__(self, index): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __imul__(self, other): ...
    def __pow__(self, other): ...
    def __ipow__(self, other): ...
    def __rpow__(self, other): ...
    def tolist(self): ...
    def sum(self, axis=..., dtype=..., out=...): ...
    def squeeze(self, axis=...): ...
    def flatten(self, order=...): ...
    def mean(self, axis=..., dtype=..., out=...): ...
    def std(self, axis=..., dtype=..., out=..., ddof=...): ...
    def var(self, axis=..., dtype=..., out=..., ddof=...): ...
    def prod(self, axis=..., dtype=..., out=...): ...
    def any(self, axis=..., out=...): ...
    def all(self, axis=..., out=...): ...
    def max(self, axis=..., out=...): ...
    def argmax(self, axis=..., out=...): ...
    def min(self, axis=..., out=...): ...
    def argmin(self, axis=..., out=...): ...
    def ptp(self, axis=..., out=...): ...
    def ravel(self, order=...): ...
    @property
    def T(self): ...
    @property
    def I(self): ...
    @property
    def A(self): ...
    @property
    def A1(self): ...
    @property
    def H(self): ...
    def getT(self): ...
    def getA(self): ...
    def getA1(self): ...
    def getH(self): ...
    def getI(self): ...

class memmap(ndarray[_ShapeType, _DType_co]):
    def __new__(
        subtype,
        filename: Any,
        dtype: Any = ...,
        mode: Any = ...,
        offset: Any = ...,
        shape: Any = ...,
        order: Any = ...,
    ) -> Any: ...
    def __getattr__(self, key: str) -> Any: ...

class nditer:
    def __new__(
        cls,
        op: Any,
        flags: Any = ...,
        op_flags: Any = ...,
        op_dtypes: Any = ...,
        order: Any = ...,
        casting: Any = ...,
        op_axes: Any = ...,
        itershape: Any = ...,
        buffersize: Any = ...,
    ) -> Any: ...
    def __getattr__(self, key: str) -> Any: ...

class poly1d:
    def __init__(
        self,
        c_or_r: Any,
        r: Any = ...,
        variable: Any = ...,
    ) -> None: ...
    def __call__(self, val: Any) -> Any: ...
    __hash__: Any
    @property
    def coeffs(self): ...
    @coeffs.setter
    def coeffs(self, value): ...
    @property
    def c(self): ...
    @c.setter
    def c(self, value): ...
    @property
    def coef(self): ...
    @coef.setter
    def coef(self, value): ...
    @property
    def coefficients(self): ...
    @coefficients.setter
    def coefficients(self, value): ...
    @property
    def variable(self): ...
    @property
    def order(self): ...
    @property
    def o(self): ...
    @property
    def roots(self): ...
    @property
    def r(self): ...
    def __array__(self, t=...): ...
    def __len__(self): ...
    def __neg__(self): ...
    def __pos__(self): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __pow__(self, val): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __div__(self, other): ...
    def __truediv__(self, other): ...
    def __rdiv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __getitem__(self, val): ...
    def __setitem__(self, key, val): ...
    def __iter__(self): ...
    def integ(self, m=..., k=...): ...
    def deriv(self, m=...): ...

class recarray(ndarray[_ShapeType, _DType_co]):
    def __new__(
        subtype,
        shape: Any,
        dtype: Any = ...,
        buf: Any = ...,
        offset: Any = ...,
        strides: Any = ...,
        formats: Any = ...,
        names: Any = ...,
        titles: Any = ...,
        byteorder: Any = ...,
        aligned: Any = ...,
        order: Any = ...,
    ) -> Any: ...
    def __array_finalize__(self, obj): ...
    def __getattribute__(self, attr): ...
    def __setattr__(self, attr, val): ...
    def __getitem__(self, indx): ...
    def field(self, attr, val=...): ...

class record(void):
    def __getattribute__(self, attr): ...
    def __setattr__(self, attr, val): ...
    def __getitem__(self, indx): ...
    def pprint(self): ...

class vectorize:
    pyfunc: Any
    cache: Any
    signature: Any
    otypes: Any
    excluded: Any
    __doc__: Any
    def __init__(
        self,
        pyfunc,
        otypes: Any = ...,
        doc: Any = ...,
        excluded: Any = ...,
        cache: Any = ...,
        signature: Any = ...,
    ) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...

# Placeholders for Python-based functions
def asmatrix(data, dtype=...): ...
def asscalar(a): ...
def cumproduct(*args, **kwargs): ...
def histogram(a, bins=..., range=..., normed=..., weights=..., density=...): ...
def histogram_bin_edges(a, bins=..., range=..., weights=...): ...
def histogramdd(sample, bins=..., range=..., normed=..., weights=..., density=...): ...
def mat(data, dtype=...): ...
def max(a, axis=..., out=..., keepdims=..., initial=..., where=...): ...
def min(a, axis=..., out=..., keepdims=..., initial=..., where=...): ...
def product(*args, **kwargs): ...
def round(a, decimals=..., out=...): ...
def round_(a, decimals=..., out=...): ...
def show_config(): ...

# Placeholders for C-based functions
# TODO: Sort out which parameters are positional-only
@overload
def arange(stop, dtype=..., *, like=...): ...
@overload
def arange(start, stop, step=..., dtype=..., *, like=...): ...
def busday_count(
    begindates,
    enddates,
    weekmask=...,
    holidays=...,
    busdaycal=...,
    out=...,
): ...
def busday_offset(
    dates,
    offsets,
    roll=...,
    weekmask=...,
    holidays=...,
    busdaycal=...,
    out=...,
): ...
def can_cast(from_, to, casting=...): ...
def compare_chararrays(a, b, cmp_op, rstrip): ...
def concatenate(__a, axis=..., out=..., dtype=..., casting=...): ...
def copyto(dst, src, casting=..., where=...): ...
def datetime_as_string(arr, unit=..., timezone=..., casting=...): ...
def datetime_data(__dtype): ...
def dot(a, b, out=...): ...
def frombuffer(buffer, dtype=..., count=..., offset=..., *, like=...): ...
def fromfile(
    file, dtype=..., count=..., sep=..., offset=..., *, like=...
): ...
def fromiter(iter, dtype, count=..., *, like=...): ...
def frompyfunc(func, nin, nout, * identity): ...
def fromstring(string, dtype=..., count=..., sep=..., *, like=...): ...
def geterrobj(): ...
def inner(a, b): ...
def is_busday(
    dates, weekmask=..., holidays=..., busdaycal=..., out=...
): ...
def lexsort(keys, axis=...): ...
def may_share_memory(a, b, max_work=...): ...
def min_scalar_type(a): ...
def nested_iters(*args, **kwargs): ...  # TODO: Sort out parameters
def promote_types(type1, type2): ...
def putmask(a, mask, values): ...
def result_type(*arrays_and_dtypes): ...
def seterrobj(errobj): ...
def shares_memory(a, b, max_work=...): ...
def vdot(a, b): ...
@overload
def where(__condition): ...
@overload
def where(__condition, __x, __y): ...

_NdArraySubClass = TypeVar("_NdArraySubClass", bound=ndarray)
_DTypeScalar_co = TypeVar("_DTypeScalar_co", covariant=True, bound=generic)
_ByteOrder = L["S", "<", ">", "=", "|", "L", "B", "N", "I"]

class dtype(Generic[_DTypeScalar_co]):
    names: Optional[Tuple[str, ...]]
    # Overload for subclass of generic
    @overload
    def __new__(
        cls,
        dtype: Type[_DTypeScalar_co],
        align: bool = ...,
        copy: bool = ...,
    ) -> dtype[_DTypeScalar_co]: ...
    # Overloads for string aliases, Python types, and some assorted
    # other special cases. Order is sometimes important because of the
    # subtype relationships
    #
    # bool < int < float < complex < object
    #
    # so we have to make sure the overloads for the narrowest type is
    # first.
    # Builtin types
    @overload
    def __new__(cls, dtype: Type[bool], align: bool = ..., copy: bool = ...) -> dtype[bool_]: ...
    @overload
    def __new__(cls, dtype: Type[int], align: bool = ..., copy: bool = ...) -> dtype[int_]: ...
    @overload
    def __new__(cls, dtype: Optional[Type[float]], align: bool = ..., copy: bool = ...) -> dtype[float_]: ...
    @overload
    def __new__(cls, dtype: Type[complex], align: bool = ..., copy: bool = ...) -> dtype[complex_]: ...
    @overload
    def __new__(cls, dtype: Type[str], align: bool = ..., copy: bool = ...) -> dtype[str_]: ...
    @overload
    def __new__(cls, dtype: Type[bytes], align: bool = ..., copy: bool = ...) -> dtype[bytes_]: ...

    # `unsignedinteger` string-based representations and ctypes
    @overload
    def __new__(cls, dtype: _UInt8Codes | Type[ct.c_uint8], align: bool = ..., copy: bool = ...) -> dtype[uint8]: ...
    @overload
    def __new__(cls, dtype: _UInt16Codes | Type[ct.c_uint16], align: bool = ..., copy: bool = ...) -> dtype[uint16]: ...
    @overload
    def __new__(cls, dtype: _UInt32Codes | Type[ct.c_uint32], align: bool = ..., copy: bool = ...) -> dtype[uint32]: ...
    @overload
    def __new__(cls, dtype: _UInt64Codes | Type[ct.c_uint64], align: bool = ..., copy: bool = ...) -> dtype[uint64]: ...
    @overload
    def __new__(cls, dtype: _UByteCodes | Type[ct.c_ubyte], align: bool = ..., copy: bool = ...) -> dtype[ubyte]: ...
    @overload
    def __new__(cls, dtype: _UShortCodes | Type[ct.c_ushort], align: bool = ..., copy: bool = ...) -> dtype[ushort]: ...
    @overload
    def __new__(cls, dtype: _UIntCCodes | Type[ct.c_uint], align: bool = ..., copy: bool = ...) -> dtype[uintc]: ...

    # NOTE: We're assuming here that `uint_ptr_t == size_t`,
    # an assumption that does not hold in rare cases (same for `ssize_t`)
    @overload
    def __new__(cls, dtype: _UIntPCodes | Type[ct.c_void_p] | Type[ct.c_size_t], align: bool = ..., copy: bool = ...) -> dtype[uintp]: ...
    @overload
    def __new__(cls, dtype: _UIntCodes | Type[ct.c_ulong], align: bool = ..., copy: bool = ...) -> dtype[uint]: ...
    @overload
    def __new__(cls, dtype: _ULongLongCodes | Type[ct.c_ulonglong], align: bool = ..., copy: bool = ...) -> dtype[ulonglong]: ...

    # `signedinteger` string-based representations and ctypes
    @overload
    def __new__(cls, dtype: _Int8Codes | Type[ct.c_int8], align: bool = ..., copy: bool = ...) -> dtype[int8]: ...
    @overload
    def __new__(cls, dtype: _Int16Codes | Type[ct.c_int16], align: bool = ..., copy: bool = ...) -> dtype[int16]: ...
    @overload
    def __new__(cls, dtype: _Int32Codes | Type[ct.c_int32], align: bool = ..., copy: bool = ...) -> dtype[int32]: ...
    @overload
    def __new__(cls, dtype: _Int64Codes | Type[ct.c_int64], align: bool = ..., copy: bool = ...) -> dtype[int64]: ...
    @overload
    def __new__(cls, dtype: _ByteCodes | Type[ct.c_byte], align: bool = ..., copy: bool = ...) -> dtype[byte]: ...
    @overload
    def __new__(cls, dtype: _ShortCodes | Type[ct.c_short], align: bool = ..., copy: bool = ...) -> dtype[short]: ...
    @overload
    def __new__(cls, dtype: _IntCCodes | Type[ct.c_int], align: bool = ..., copy: bool = ...) -> dtype[intc]: ...
    @overload
    def __new__(cls, dtype: _IntPCodes | Type[ct.c_ssize_t], align: bool = ..., copy: bool = ...) -> dtype[intp]: ...
    @overload
    def __new__(cls, dtype: _IntCodes | Type[ct.c_long], align: bool = ..., copy: bool = ...) -> dtype[int_]: ...
    @overload
    def __new__(cls, dtype: _LongLongCodes | Type[ct.c_longlong], align: bool = ..., copy: bool = ...) -> dtype[longlong]: ...

    # `floating` string-based representations and ctypes
    @overload
    def __new__(cls, dtype: _Float16Codes, align: bool = ..., copy: bool = ...) -> dtype[float16]: ...
    @overload
    def __new__(cls, dtype: _Float32Codes, align: bool = ..., copy: bool = ...) -> dtype[float32]: ...
    @overload
    def __new__(cls, dtype: _Float64Codes, align: bool = ..., copy: bool = ...) -> dtype[float64]: ...
    @overload
    def __new__(cls, dtype: _HalfCodes, align: bool = ..., copy: bool = ...) -> dtype[half]: ...
    @overload
    def __new__(cls, dtype: _SingleCodes | Type[ct.c_float], align: bool = ..., copy: bool = ...) -> dtype[single]: ...
    @overload
    def __new__(cls, dtype: _DoubleCodes | Type[ct.c_double], align: bool = ..., copy: bool = ...) -> dtype[double]: ...
    @overload
    def __new__(cls, dtype: _LongDoubleCodes | Type[ct.c_longdouble], align: bool = ..., copy: bool = ...) -> dtype[longdouble]: ...

    # `complexfloating` string-based representations
    @overload
    def __new__(cls, dtype: _Complex64Codes, align: bool = ..., copy: bool = ...) -> dtype[complex64]: ...
    @overload
    def __new__(cls, dtype: _Complex128Codes, align: bool = ..., copy: bool = ...) -> dtype[complex128]: ...
    @overload
    def __new__(cls, dtype: _CSingleCodes, align: bool = ..., copy: bool = ...) -> dtype[csingle]: ...
    @overload
    def __new__(cls, dtype: _CDoubleCodes, align: bool = ..., copy: bool = ...) -> dtype[cdouble]: ...
    @overload
    def __new__(cls, dtype: _CLongDoubleCodes, align: bool = ..., copy: bool = ...) -> dtype[clongdouble]: ...

    # Miscellaneous string-based representations and ctypes
    @overload
    def __new__(cls, dtype: _BoolCodes | Type[ct.c_bool], align: bool = ..., copy: bool = ...) -> dtype[bool_]: ...
    @overload
    def __new__(cls, dtype: _TD64Codes, align: bool = ..., copy: bool = ...) -> dtype[timedelta64]: ...
    @overload
    def __new__(cls, dtype: _DT64Codes, align: bool = ..., copy: bool =